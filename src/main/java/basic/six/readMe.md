*1.(快慢指针)给定一个链表的头节点，如果链表中节点个数为奇数 返回中点位置的节点 如果链表的中的个数为偶数 返回上中点位置的节点
    快慢指针 快指针走两步 慢指针走一步 当快指针走完的时候  慢指针正好来到中点位置
    初始情况下 slow指向第二个节点  fast指向第三个节点
    循环条件 fast.next != null && fase.next.next != null 

2.(快慢指针)给定一个链表的头节点，如果链表中的节点个数为奇数 返回中点位置的节点 如果链表中的节点个数为偶数 返回下中点位置的节点。

3.(快慢指针)给定一个链表的头节点，如果链表中的节点个数为奇数 返回中点位置的前一个节点 如果链表中的节点个数为偶数 返回上中点位置的前一个节点。

4.(快慢指针)给定一个链表的头节点，如果链表中的节点个数为奇数 返回中点位置的前一个节点 如果链表中的节点个数为偶数 返回下中点位置的前一个节点。
 
**5.给定一个单链表的头节点head，请判断该链表是否为回文结构(正向反向念一样)
    1)栈的方法 最容易想到的方法 循环遍历压入栈中 循环与栈中的进行比较 不一样就不是回文 
    2)修改原链表的方法 找到中点位置  后续 反转 然后 头尾指针比较  返回答案前 调回 
    3)快慢指针 找中点 中点后位置压栈 比对  
**6.将单向链表按某值 划分成左边小，中间相等，右边大的形式
    1)链表放入数组中进行 partition 过程 笔试
    2)分成小 中 大 三部分 然后串起来(*串起来的过程很重要)。面试
        六个指针   
**7.一种特殊的单链表节点类描述如下
    class Node{
        int value;
        Node next;
        Node rand;
        Node(int value){
            this.value = value
        }
    }
    rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null;
    给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
    时间复杂度O(n) 空间复杂度O(1)   hashMap<Node,Node'>
    1)使用hash表的方式
    2)操作链表 
        1.构建 1-》1‘-》2-》2’-》3-》3‘-》null
        2.取两个为一组操作 设置clone节点的rand
        3.分离
**给定两个可能有环也有可能无环的单链表，头节点head1和head2.请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交返回null
要求:如果两个链表长度之和为N,时间复杂度请达到O(N),额外空间复杂度O(1);
    1.如何判断链表有环还是没环
